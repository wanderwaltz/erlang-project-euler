-module(pe12).
-export([solve/0, benchmark/0]).

% The sequence of triangle numbers is generated by adding the natural numbers. 
% So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
% 
% The first ten terms would be:
% 
% 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
% 
% Let us list the factors of the first seven triangle numbers:
% 
%  1: 1
%  3: 1,3
%  6: 1,2,3,6
% 10: 1,2,5,10
% 15: 1,3,5,15
% 21: 1,3,7,21
% 28: 1,2,4,7,14,28
% We can see that 28 is the first triangle number to have over five divisors.
% 
% What is the value of the first triangle number to have over five hundred divisors?
%--------------------------

%=== A 'THINK A LITTLE' SOLUTION
% N'th triangle number is a sum of 1+2+...+N, an arithmetic progression,
% so it's value could be evaluated as N*(N+1)/2.
% 
% We also can state that N and N+1 do not have any common divisors except 1
% Proof: N = A*B, N+1 = A*C, so A*B + 1 = A*C, so A should divide 1 also.
% 
% What does this give us? Either N or N+1 is even, so either N/2 or (N+1)/2
% is a natural number, and we have two situations:
% N/2, N+1 or N, (N+1)/2 where both of the numbers do not share common
% divisors except 1.
%
% We then count the number of divisors of both these numbers, and multiply
% found values. This gives us the number of divisors of the Nth triangle
% number. 
%
solve() -> first_tri_divisors(500).


% Returns number of different divisors of N*(N+1)/2.
triangle_divisors(N) when N rem 2 == 0 ->
	DN  = num_divisors(N div 2),
	DN1 = num_divisors(N+1),
	DN * DN1;

triangle_divisors(N) ->
	DN  = num_divisors(N),
	DN1 = num_divisors((N+1) div 2),
	DN * DN1.


% Finds first triangle number with number of divisors > MaxDivisors
% (by iterating all possible triangle numbers)
first_tri_divisors(MaxDivisors) -> first_tri_divisors(MaxDivisors, 1).

first_tri_divisors(MaxDivisors, I) ->
	Divisors = triangle_divisors(I),

	if Divisors > MaxDivisors -> I * (I+1) div 2;
		true -> first_tri_divisors(MaxDivisors, I+1)
	end.


% Brute-force search of the number of divisors for a given N
num_divisors(N) -> num_divisors(N, 2, 2, math:sqrt(N)). % start with count == 2 because 1 and N are dividers for every N


num_divisors(_, Current, Num, Max) when Current > Max -> Num;
num_divisors(N, Current, Num, Max) when N rem Current == 0 -> num_divisors(N, Current+1, Num+2, Max);
num_divisors(N, Current, Num, Max) -> num_divisors(N, Current+1, Num, Max).


%=== BENCHMARK

benchmark() ->
    {S1Time, S1Result} = timer:tc(?MODULE, solve, []),
    io:format("solve: ~p (~p ms)~n", [S1Result, S1Time/1000]).